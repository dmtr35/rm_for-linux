#!/bin/bash

if [ -n "$SUDO_USER" ]; then
    # Если скрипт запущен с sudo, используйте $SUDO_USER
    user="$SUDO_USER"
    home=$(eval echo ~$user)
else
    # В противном случае используйте текущего пользователя
    user="$USER"
    home="$HOME"
fi

date="$(date +'%d-%m-%Y_%H-%M-%S')"
trash="$home/.my_trash"
hash -r
rm="$(which -a rm | grep -v '/usr/local/bin/rm' | awk 'NR==1 {print}')"

# проверка есть ли корзина, и создать если нет 
if [ ! -d "$trash" ]; then
	mkdir -p "$trash"
fi
# если нету аргументов, выход
[ "$#" -eq 0 ] && echo "no filename" && exit


checkTrash() {
		if [ -d "$file" ] && [ "$file" == "$trash" ]; then
		$rm -rf $trash/*
		return 1 
	fi
}

checkFile() {
	if [ ! -e "$file" ] && [ ! -L "$file" ] && [ "$check_v" == "true" ]; then
		echo "Файл '$file' не существует."
		return 1
	elif [ ! -e "$file" ]&& [ ! -L "$file" ]; then
		echo "Файл '$file' не существует."
		return 1
	fi
}


removeAndSave() {
	if [ "$#" -ge 1 ]; then
		# цикл на перемещение и удаление файла
		for file in "$@"
		do
			filePath=$(realpath -s $file)
			fileName=$(basename $filePath)
			currentChange=$(echo $filePath | awk '{gsub("/", "-"); print}')
			fileNameDate="${fileName}____${date}"
			checkTrash "$filePath"
			if [ "$?" -eq 1 ]; then
				continue 
			fi
			checkFile "$filePath"
			if [ "$?" -ne 0 ]; then
				continue
			fi
			# перед перемещением файла, переименовываем его, добавляя дату
			tar -czf /$trash/${fileNameDate}_${currentChange}.tar.gz --absolute-names $filePath

			$rm -rf "$filePath"
			if [ "$?" -ne 0 ] && [ "$check_v" == "true" ]; then
				$rm -rf $trash/${fileNameDate}_${currentChange}.tar.gz $filePath
				echo 'Permission denied'
				continue
			elif [ "$check_v" == "true" ]; then
				echo "removed&save: $fileName"
			fi
		done
	fi
}

remove() {
	# цикл на удаление файлов, без сохранения
	for file in "$@"
	do
		filePath=$(realpath -s $file)
		fileName=$(basename $filePath)
		checkTrash "$filePath"
		if [ "$?" -eq 1 ]; then
			continue 
		fi
		checkFile "$filePath"
		if [ "$?" -ne 0 ]; then
			continue
		fi
		$rm -rf "$filePath"
		if [ "$check_v" == "true" ]; then 
			echo "removed: $fileName"
		fi
	done
}

restore() {
	# цикл на восстановление каждого файла в свою директорию
	for file in "$@"
	do
		filePath=$(realpath -s $file)
		fileName=$(basename $filePath)
		restoreFilePathAll=$(echo "$fileName" | awk '{gsub("-", "/"); print}' | awk '{print substr($0, 1, length($0)-7)}' | awk -F'_' '{print $NF}')
	  restoreFileName=$(basename $restoreFilePathAll)
	  restoreFilePath=$(dirname $restoreFilePathAll)

		checkFile "$filePath"
		if [ "$?" -ne 0 ]; then
			continue
		fi

		tar -xzf $filePath --absolute-names -C $restoreFilePath
		if [ "$?" -eq 2 ] && [ "$check_v" == "true" ]; then
			echo 'Cannot open: Permission denied'
			continue
		elif [ "$?" -eq 2 ]; then
			continue
		fi

		rm -rf $filePath
		if [ "$check_v" == "true" ]; then 
			echo "file: $restoreFileName => restored: $restoreFilePathAll"
		fi

	done
}


case $1 in
	-r)
		if [ "$#" -eq 1 ]; then
			echo "no filename"
			exit
		fi
		shift
		if [ "$1" == "-v" ]; then
			check_v=true
			shift
		fi
		remove "$@"
		;;
	-rv | -vr)
		[ "$#" -eq 1 ] && echo "no filename" && exit
		check_v=true
		shift
		remove "$@"
		;;


	-u)
		if [ "$#" -eq 1 ]; then
			echo "no filename"
			exit
		fi
		shift
		if [ "$1" == "-v" ]; then
			check_v=true
			shift
		fi
		restore "$@"
		;;
	-uv | -vu)
		[ "$#" -eq 1 ] && echo "no filename" && exit
		check_v=true
		shift
		restore "$@"
		;;


	-v)
		if [ "$#" -eq 1 ]; then
			echo "no filename"
			exit
		fi
		shift
		if [ "$1" == "-r" ]; then
			check_v=true
			shift
			remove "$@"
			exit
		elif [ "$1" == "-u" ]; then
			check_v=true
			shift
			restore "$@"
			exit
		fi
		check_v=true
		removeAndSave "$@"
		;;

	-h | --help) 
		[ "$#" -gt 1 ] && echo "too many arguments" && exit
		echo "
DESCRIPTION
   put the program in /usr/local/bin/
SYNOPSIS
   rm [OPTION]... [FILE]...				
OPTIONS
   -r: without saving the file, normal deletion without recovery

   -u: files that were saved in the /home/<user>/.my_trash directory are restored using -u
       
   -v: receive a report on completed work

   -h,--help: help
"
		;;

	 *) removeAndSave "$@"
		;;

	esac





